#include <stdio.h>
#include <stdbool.h>

#define MAX_STUDENTS 20000
#define NUM_SUBJECTS 5
#define MAX_M 30

// ----------------------------
// Global Data Structures
// ----------------------------
int studentScores[MAX_STUDENTS + 1000][NUM_SUBJECTS];
int universityScores[MAX_STUDENTS + 1000][MAX_M + 1];

int activeStudents[MAX_STUDENTS];
int activeCount = 0;
bool isActive[MAX_STUDENTS + 1] = { false };
int assignedUniversity[MAX_STUDENTS + 1] = { 0 };
bool needsUpdate = true;

typedef struct {
	int weights[NUM_SUBJECTS];
} University;

typedef struct {
	int N;
	int M;
	University universities[MAX_M + 1];
} Data;

static Data globalData;

// ----------------------------
// Utility
// ----------------------------
static inline void swap_int(int* a, int* b)
{
	int t = *a; *a = *b; *b = t;
}

// ----------------------------
// Initialization
// ----------------------------
void init(int N, int M, int mWeights[][NUM_SUBJECTS])
{
	for (int i = 0; i < MAX_STUDENTS + 1000; i++)
		for (int j = 0; j < NUM_SUBJECTS; j++)
			studentScores[i][j] = 0;

	for (int i = 1; i <= MAX_M; i++)
		for (int j = 0; j < NUM_SUBJECTS; j++)
			globalData.universities[i].weights[j] = 0;

	activeCount = 0;
	for (int i = 0; i <= MAX_STUDENTS; i++) {
		isActive[i] = false;
		assignedUniversity[i] = 0;
	}

	needsUpdate = true;
	globalData.N = N;
	globalData.M = M;

	for (int i = 1; i <= M; i++)
		for (int j = 0; j < NUM_SUBJECTS; j++)
			globalData.universities[i].weights[j] = mWeights[i - 1][j];
}

// ----------------------------
// Add Student
// ----------------------------
void add(int mID, int mScores[NUM_SUBJECTS])
{
	if (mID > MAX_STUDENTS) return;

	if (!isActive[mID]) {
		activeStudents[activeCount++] = mID;
		isActive[mID] = true;
	}
	needsUpdate = true;

	for (int j = 0; j < NUM_SUBJECTS; j++)
		studentScores[mID][j] = mScores[j];

	for (int u = 1; u <= globalData.M; u++) {
		universityScores[mID][u] =
			mScores[0] * globalData.universities[u].weights[0] +
			mScores[1] * globalData.universities[u].weights[1] +
			mScores[2] * globalData.universities[u].weights[2] +
			mScores[3] * globalData.universities[u].weights[3] +
			mScores[4] * globalData.universities[u].weights[4];
	}
}

// ----------------------------
// Erase Student
// ----------------------------
void erase(int mID)
{
	if (mID > MAX_STUDENTS || !isActive[mID]) return;
	isActive[mID] = false;
	needsUpdate = true;
}

// ----------------------------
// Quickselect Helpers
// ----------------------------
int partition(int arr[], int scores[][MAX_M + 1], int left, int right, int pivotIdx, int uID)
{
	int pivotScore = scores[arr[pivotIdx]][uID];
	swap_int(&arr[pivotIdx], &arr[right]);
	int store = left;
	for (int i = left; i < right; i++) {
		int s = scores[arr[i]][uID];
		if (s > pivotScore || (s == pivotScore && arr[i] < arr[right])) {
			swap_int(&arr[i], &arr[store]);
			store++;
		}
	}
	swap_int(&arr[store], &arr[right]);
	return store;
}

void quickselect_topN(int arr[], int scores[][MAX_M + 1], int left, int right, int N, int uID)
{
	while (left < right) {
		int pivotIdx = (left + right) / 2;
		int pivotNew = partition(arr, scores, left, right, pivotIdx, uID);
		int rank = pivotNew - left + 1;
		if (rank == N) return;
		else if (rank > N) right = pivotNew - 1;
		else { N -= rank; left = pivotNew + 1; }
	}
}

// ----------------------------
// Update Assignments (optimized)
// ----------------------------
void updateAssignments(void)
{
	for (int i = 0; i <= MAX_STUDENTS; i++)
		assignedUniversity[i] = 0;

	int remaining[MAX_STUDENTS];
	int count = 0;
	for (int i = 0; i < activeCount; i++)
		if (isActive[activeStudents[i]])
			remaining[count++] = activeStudents[i];

	static bool assigned[MAX_STUDENTS + 1];
	for (int i = 0; i <= MAX_STUDENTS; i++) assigned[i] = false;

	for (int u = 1; u <= globalData.M && count > 0; u++) {

		if (count <= globalData.N) {
			for (int i = 0; i < count; i++)
				assignedUniversity[remaining[i]] = u;
			break;
		}

		// Select top N efficiently
		quickselect_topN(remaining, universityScores, 0, count - 1, globalData.N, u);

		// Assign top N
		int newCount = 0;
		for (int i = 0; i < count; i++) {
			int sid = remaining[i];
			if (i < globalData.N) {
				assignedUniversity[sid] = u;
				assigned[sid] = true;
			}
			else {
				if (!assigned[sid]) remaining[newCount++] = sid;
			}
		}
		count = newCount;
	}

	needsUpdate = false;
}

// ----------------------------
// Suggest (final output)
// ----------------------------
int suggest(int mID)
{
	if (needsUpdate) updateAssignments();
	return assignedUniversity[mID] != 0 ? assignedUniversity[mID] : -1;
}
